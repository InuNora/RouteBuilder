####
# Я исхожу из соображений, что раз гарантируется, что маршруты не содержат разрывов и закольцованностей,
# то каждый город  в цепочке встречается не больше 2х раз, один для From, другой для To.
# Если же город встретится в третий раз, будь то самый начальный или конечный пункт в цепочке,
# то мы неизбежно получим закольцованность или разрыв.
#
# Исходя из этого можно воспользоваться простой структурой, вроде массива или списка.
# При получении исходны данных мы присваивает каждому городу уникальный ID, который будет в дальнейшем соответствовать
# элементу в ячейке.
#
# Исходя из этого мне видится первая структура - словарь, в котором ключем является город, а значением его ID.
# Вторая структура вида массива, где в ячейку с ID From будет записываться ID To.
#
# Проверки на валидность строки я намеренно не пишу. Как и многие другие проверки.
# Понятно, что нужно проверять на всё, но это не задача данного конкретного задания.
####

####
# CityID = dict( 'city' = 'id' )
# Path = []
####

import re

CityID = dict()
CityIDRevers = dict()
Path = []

TestIN = '((‘Москва’, ‘Тюмень’), (‘Тюмень’, ‘Сочи’), (‘Ростов-на-Дону’, ‘Москва’))'

# составляем словарь городов
pattern1 = re.compile('[А-ЯЁ][а-яё\-А-ЯЁ]+')
cities = re.findall(pattern1, TestIN)
for city in cities:
    if city not in CityID.keys():
        CityIDRevers[len(CityID)] = city
        CityID[city] = len(CityID)

# инициализируем список Path
for i in range(len(CityID)):
    Path.append("")


# анализируем пары
pattern2 = re.compile('‘[А-ЯЁ][а-яё\-А-ЯЁ]+’, ‘[А-ЯЁ][а-яё\-А-ЯЁ]+’')
pair = re.findall(pattern2, TestIN)

for chainlink in pair:
    city = re.findall(pattern1, chainlink)
    From = CityID[city[0]]
    To = CityID[city[1]]
    Path[From] = To     # добавить в структуру Path

# ищем первый элемент цепочки - тот, на который не ссылаются в списке
first = set(CityID.values())
for id in Path:
    first.discard(id) # может попасться пустой элемент. Можно добавить проверку на это
# первый элемент хранится в cities. Если их больше одного, то можно выкидывать ошибку, так как путь получился не связным

# создаем результирующую цепочку
next = list(first)[0]
result = [CityIDRevers[next]]
for i in range(len(CityID) - 1):
    next = Path[next]
    result.append(CityIDRevers[next])

resultString = "('" + "', '" . join(result) + "')"
print (resultString)
